//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.5-2 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.08.04 at 02:28:19 PM CEST 
//


package com.ptc.tifworkbench.jaxbbinding;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for FieldReference complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="FieldReference">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="editability" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="relevance" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="traces">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;sequence>
 *                   &lt;element name="trace" maxOccurs="unbounded" minOccurs="0">
 *                     &lt;complexType>
 *                       &lt;complexContent>
 *                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                           &lt;attribute name="target" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                         &lt;/restriction>
 *                       &lt;/complexContent>
 *                     &lt;/complexType>
 *                   &lt;/element>
 *                 &lt;/sequence>
 *                 &lt;attribute name="backward" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                 &lt;attribute name="description" type="{http://www.w3.org/2001/XMLSchema}string" />
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="description" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *         &lt;element name="default" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *         &lt;element name="constraint" type="{http://www.ptc.com/integrity-solution}ConstraintDefinition"/>
 *       &lt;/sequence>
 *       &lt;attribute name="name" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="display-name" type="{http://www.w3.org/2001/XMLSchema}string" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "FieldReference", propOrder = {
    "editability",
    "relevance",
    "traces",
    "description",
    "_default",
    "constraint"
})
public class FieldReference
    implements Equals, HashCode, ToString
{

    protected String editability;
    protected String relevance;
    @XmlElement(required = true)
    protected FieldReference.Traces traces;
    @XmlElement(required = true)
    protected String description;
    @XmlElement(name = "default", required = true)
    protected String _default;
    @XmlElement(required = true)
    protected ConstraintDefinition constraint;
    @XmlAttribute(name = "name")
    protected String name;
    @XmlAttribute(name = "display-name")
    protected String displayName;

    /**
     * Gets the value of the editability property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getEditability() {
        return editability;
    }

    /**
     * Sets the value of the editability property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setEditability(String value) {
        this.editability = value;
    }

    /**
     * Gets the value of the relevance property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getRelevance() {
        return relevance;
    }

    /**
     * Sets the value of the relevance property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setRelevance(String value) {
        this.relevance = value;
    }

    /**
     * Gets the value of the traces property.
     * 
     * @return
     *     possible object is
     *     {@link FieldReference.Traces }
     *     
     */
    public FieldReference.Traces getTraces() {
        return traces;
    }

    /**
     * Sets the value of the traces property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldReference.Traces }
     *     
     */
    public void setTraces(FieldReference.Traces value) {
        this.traces = value;
    }

    /**
     * Gets the value of the description property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * Gets the value of the default property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDefault() {
        return _default;
    }

    /**
     * Sets the value of the default property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDefault(String value) {
        this._default = value;
    }

    /**
     * Gets the value of the constraint property.
     * 
     * @return
     *     possible object is
     *     {@link ConstraintDefinition }
     *     
     */
    public ConstraintDefinition getConstraint() {
        return constraint;
    }

    /**
     * Sets the value of the constraint property.
     * 
     * @param value
     *     allowed object is
     *     {@link ConstraintDefinition }
     *     
     */
    public void setConstraint(ConstraintDefinition value) {
        this.constraint = value;
    }

    /**
     * Gets the value of the name property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setName(String value) {
        this.name = value;
    }

    /**
     * Gets the value of the displayName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Sets the value of the displayName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDisplayName(String value) {
        this.displayName = value;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof FieldReference)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final FieldReference that = ((FieldReference) object);
        {
            String lhsEditability;
            lhsEditability = this.getEditability();
            String rhsEditability;
            rhsEditability = that.getEditability();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "editability", lhsEditability), LocatorUtils.property(thatLocator, "editability", rhsEditability), lhsEditability, rhsEditability)) {
                return false;
            }
        }
        {
            String lhsRelevance;
            lhsRelevance = this.getRelevance();
            String rhsRelevance;
            rhsRelevance = that.getRelevance();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "relevance", lhsRelevance), LocatorUtils.property(thatLocator, "relevance", rhsRelevance), lhsRelevance, rhsRelevance)) {
                return false;
            }
        }
        {
            FieldReference.Traces lhsTraces;
            lhsTraces = this.getTraces();
            FieldReference.Traces rhsTraces;
            rhsTraces = that.getTraces();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "traces", lhsTraces), LocatorUtils.property(thatLocator, "traces", rhsTraces), lhsTraces, rhsTraces)) {
                return false;
            }
        }
        {
            String lhsDescription;
            lhsDescription = this.getDescription();
            String rhsDescription;
            rhsDescription = that.getDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "description", lhsDescription), LocatorUtils.property(thatLocator, "description", rhsDescription), lhsDescription, rhsDescription)) {
                return false;
            }
        }
        {
            String lhsDefault;
            lhsDefault = this.getDefault();
            String rhsDefault;
            rhsDefault = that.getDefault();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "_default", lhsDefault), LocatorUtils.property(thatLocator, "_default", rhsDefault), lhsDefault, rhsDefault)) {
                return false;
            }
        }
        {
            ConstraintDefinition lhsConstraint;
            lhsConstraint = this.getConstraint();
            ConstraintDefinition rhsConstraint;
            rhsConstraint = that.getConstraint();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "constraint", lhsConstraint), LocatorUtils.property(thatLocator, "constraint", rhsConstraint), lhsConstraint, rhsConstraint)) {
                return false;
            }
        }
        {
            String lhsName;
            lhsName = this.getName();
            String rhsName;
            rhsName = that.getName();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "name", lhsName), LocatorUtils.property(thatLocator, "name", rhsName), lhsName, rhsName)) {
                return false;
            }
        }
        {
            String lhsDisplayName;
            lhsDisplayName = this.getDisplayName();
            String rhsDisplayName;
            rhsDisplayName = that.getDisplayName();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "displayName", lhsDisplayName), LocatorUtils.property(thatLocator, "displayName", rhsDisplayName), lhsDisplayName, rhsDisplayName)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = 1;
        {
            String theEditability;
            theEditability = this.getEditability();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "editability", theEditability), currentHashCode, theEditability);
        }
        {
            String theRelevance;
            theRelevance = this.getRelevance();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "relevance", theRelevance), currentHashCode, theRelevance);
        }
        {
            FieldReference.Traces theTraces;
            theTraces = this.getTraces();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "traces", theTraces), currentHashCode, theTraces);
        }
        {
            String theDescription;
            theDescription = this.getDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "description", theDescription), currentHashCode, theDescription);
        }
        {
            String theDefault;
            theDefault = this.getDefault();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "_default", theDefault), currentHashCode, theDefault);
        }
        {
            ConstraintDefinition theConstraint;
            theConstraint = this.getConstraint();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "constraint", theConstraint), currentHashCode, theConstraint);
        }
        {
            String theName;
            theName = this.getName();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "name", theName), currentHashCode, theName);
        }
        {
            String theDisplayName;
            theDisplayName = this.getDisplayName();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "displayName", theDisplayName), currentHashCode, theDisplayName);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        {
            String theEditability;
            theEditability = this.getEditability();
            strategy.appendField(locator, this, "editability", buffer, theEditability);
        }
        {
            String theRelevance;
            theRelevance = this.getRelevance();
            strategy.appendField(locator, this, "relevance", buffer, theRelevance);
        }
        {
            FieldReference.Traces theTraces;
            theTraces = this.getTraces();
            strategy.appendField(locator, this, "traces", buffer, theTraces);
        }
        {
            String theDescription;
            theDescription = this.getDescription();
            strategy.appendField(locator, this, "description", buffer, theDescription);
        }
        {
            String theDefault;
            theDefault = this.getDefault();
            strategy.appendField(locator, this, "_default", buffer, theDefault);
        }
        {
            ConstraintDefinition theConstraint;
            theConstraint = this.getConstraint();
            strategy.appendField(locator, this, "constraint", buffer, theConstraint);
        }
        {
            String theName;
            theName = this.getName();
            strategy.appendField(locator, this, "name", buffer, theName);
        }
        {
            String theDisplayName;
            theDisplayName = this.getDisplayName();
            strategy.appendField(locator, this, "displayName", buffer, theDisplayName);
        }
        return buffer;
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence>
     *         &lt;element name="trace" maxOccurs="unbounded" minOccurs="0">
     *           &lt;complexType>
     *             &lt;complexContent>
     *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 &lt;attribute name="target" type="{http://www.w3.org/2001/XMLSchema}string" />
     *               &lt;/restriction>
     *             &lt;/complexContent>
     *           &lt;/complexType>
     *         &lt;/element>
     *       &lt;/sequence>
     *       &lt;attribute name="backward" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       &lt;attribute name="description" type="{http://www.w3.org/2001/XMLSchema}string" />
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "trace"
    })
    public static class Traces
        implements Equals, HashCode, ToString
    {

        protected List<FieldReference.Traces.Trace> trace;
        @XmlAttribute(name = "backward")
        protected String backward;
        @XmlAttribute(name = "description")
        protected String description;

        /**
         * Gets the value of the trace property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the trace property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getTrace().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link FieldReference.Traces.Trace }
         * 
         * 
         */
        public List<FieldReference.Traces.Trace> getTrace() {
            if (trace == null) {
                trace = new ArrayList<FieldReference.Traces.Trace>();
            }
            return this.trace;
        }

        /**
         * Gets the value of the backward property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getBackward() {
            return backward;
        }

        /**
         * Sets the value of the backward property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setBackward(String value) {
            this.backward = value;
        }

        /**
         * Gets the value of the description property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDescription() {
            return description;
        }

        /**
         * Sets the value of the description property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDescription(String value) {
            this.description = value;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof FieldReference.Traces)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final FieldReference.Traces that = ((FieldReference.Traces) object);
            {
                List<FieldReference.Traces.Trace> lhsTrace;
                lhsTrace = this.getTrace();
                List<FieldReference.Traces.Trace> rhsTrace;
                rhsTrace = that.getTrace();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "trace", lhsTrace), LocatorUtils.property(thatLocator, "trace", rhsTrace), lhsTrace, rhsTrace)) {
                    return false;
                }
            }
            {
                String lhsBackward;
                lhsBackward = this.getBackward();
                String rhsBackward;
                rhsBackward = that.getBackward();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "backward", lhsBackward), LocatorUtils.property(thatLocator, "backward", rhsBackward), lhsBackward, rhsBackward)) {
                    return false;
                }
            }
            {
                String lhsDescription;
                lhsDescription = this.getDescription();
                String rhsDescription;
                rhsDescription = that.getDescription();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "description", lhsDescription), LocatorUtils.property(thatLocator, "description", rhsDescription), lhsDescription, rhsDescription)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<FieldReference.Traces.Trace> theTrace;
                theTrace = this.getTrace();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "trace", theTrace), currentHashCode, theTrace);
            }
            {
                String theBackward;
                theBackward = this.getBackward();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "backward", theBackward), currentHashCode, theBackward);
            }
            {
                String theDescription;
                theDescription = this.getDescription();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "description", theDescription), currentHashCode, theDescription);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<FieldReference.Traces.Trace> theTrace;
                theTrace = this.getTrace();
                strategy.appendField(locator, this, "trace", buffer, theTrace);
            }
            {
                String theBackward;
                theBackward = this.getBackward();
                strategy.appendField(locator, this, "backward", buffer, theBackward);
            }
            {
                String theDescription;
                theDescription = this.getDescription();
                strategy.appendField(locator, this, "description", buffer, theDescription);
            }
            return buffer;
        }


        /**
         * <p>Java class for anonymous complex type.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.
         * 
         * <pre>
         * &lt;complexType>
         *   &lt;complexContent>
         *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       &lt;attribute name="target" type="{http://www.w3.org/2001/XMLSchema}string" />
         *     &lt;/restriction>
         *   &lt;/complexContent>
         * &lt;/complexType>
         * </pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class Trace
            implements Equals, HashCode, ToString
        {

            @XmlAttribute(name = "target")
            protected String target;

            /**
             * Gets the value of the target property.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getTarget() {
                return target;
            }

            /**
             * Sets the value of the target property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             */
            public void setTarget(String value) {
                this.target = value;
            }

            public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
                if (!(object instanceof FieldReference.Traces.Trace)) {
                    return false;
                }
                if (this == object) {
                    return true;
                }
                final FieldReference.Traces.Trace that = ((FieldReference.Traces.Trace) object);
                {
                    String lhsTarget;
                    lhsTarget = this.getTarget();
                    String rhsTarget;
                    rhsTarget = that.getTarget();
                    if (!strategy.equals(LocatorUtils.property(thisLocator, "target", lhsTarget), LocatorUtils.property(thatLocator, "target", rhsTarget), lhsTarget, rhsTarget)) {
                        return false;
                    }
                }
                return true;
            }

            public boolean equals(Object object) {
                final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
                return equals(null, null, object, strategy);
            }

            public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
                int currentHashCode = 1;
                {
                    String theTarget;
                    theTarget = this.getTarget();
                    currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "target", theTarget), currentHashCode, theTarget);
                }
                return currentHashCode;
            }

            public int hashCode() {
                final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
                return this.hashCode(null, strategy);
            }

            public String toString() {
                final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
                final StringBuilder buffer = new StringBuilder();
                append(null, buffer, strategy);
                return buffer.toString();
            }

            public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
                strategy.appendStart(locator, this, buffer);
                appendFields(locator, buffer, strategy);
                strategy.appendEnd(locator, this, buffer);
                return buffer;
            }

            public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
                {
                    String theTarget;
                    theTarget = this.getTarget();
                    strategy.appendField(locator, this, "target", buffer, theTarget);
                }
                return buffer;
            }

        }

    }

}
